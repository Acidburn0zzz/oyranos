/**
    @mainpage
    <h3 align="center">Copyright 2004-2007 &copy; Kai-Uwe Behrmann</h3>

    @section text_contents Descriptive Contents
    @ref intro |
    @ref concepts |
    @ref install |
    @ref links\n
    @ref tools |
    @ref user |
    @ref coding |
    @ref api_tutorial

    @author Kai-Uwe Behrmann
    @date Project start: March 2004

    <dl compact><dt><b>Internet:</b></dt><dd>http://www.oyranos.org</dd></dl>

    @n@n
    @section intro Introduction
  
    Oyranos is intended as a entry point for colour savy applications.
    In its current stage it configures profile paths, sets default profiles, 
    maps devices to profiles, sets a monitor profile in X and uploads a vcgt
    tag. This means for instance all applications using Oyranos will use for
    a incoming digital camera picture the same profile and watch it through the
    same monitor profile with the same options for rendering intent, simulation
    and so on.

    @section tools User Tools Documentation
    - oyranos-monitor - a commandline tool for calling from a setup script like
      .xinitrc. It selects a profile for the current monitor and sets up the
      X server at startup time. Usage:
    @verbatim
    # select a monitor profile, load the binary blob into X and fill the
    # VideoCardGammaTable, if appropriate
    oyranos-monitor
    @endverbatim
    - oyranos-policy - a tool to set a policy from a xml file. Use it like:
    @verbatim
    oyranos-policy `oyranos-config --syscolordir`/`oyranos-config --settingsdirname`/office.policy.xml
    @endverbatim
    Affected are default profiles and some behaviour settings.
    - <a href="http://www.oyranos.org/wiki/index.php?title=Oyranos_Configuration_Dialog">oyranos-config-fltk</a> - a configuration UI application, using some functions      of the Oyranos APIs. If you have <a href="http://www.oyranos.org/wiki/index.php?title=ICC_Examin">ICC Examin</a> installed it can be called to
      show details of profiles. 
    - oyranos-config - a command line tool to get compiler flags to using Oyranos in your own project. Try  \i oyranos-config \i --help to see the appropriate options.

    @section user User API Documentation
    The basic Oyranos API gets included with oyranos.h. An application, which
    wants to use these functions, needs to link against Oyranos and Elektra.
    - @ref policy - load / save of user policies
    - @ref options - layout and describe options to the user; part of user policies
    - @ref behaviour - get and set common behaviour; part of user policies
    - @ref default_profiles - get and set commonly used profiles; part of user policies
    - @ref path_names  - get information about configured and used profile search paths 
    - @ref profile_lists - provides the search path content as profile lists for your GUI
    - @ref profile_handling - file I/O and more

    The monitor related API is contained in oyranos_monitor.h. Linkage on Linux
    needs X11. Therefore this library part is separated from the main one. 
    - @ref monitor_api - monitor profile configuration

    The key names, which Oyranos uses to store its configuration in an Elektra
    file tree, are defined in oyranos_definitions.h.
    \n

    More toppics about programming with Oyranos can be found on the @ref coding
    page. 

    @subsection api_tutorial Programming Tutorial
    Frist you have to put a
    @verbatim
    #include <oyranos/oyranos.h>
    int oyranos_version = oyVersion();
    @endverbatim
    in your source text, in order to use Oyranos. \b oyranos-config \b --cflags delivers the compiler flags and \b oyranos-config \b --ldflags the linker flags.

    Then you can put Oyranos functions in your code and compile with:
    @verbatim
    cc `oyranos-config --cflags` `oyranos-config --ldflags` mycode.c -o myApp
    @endverbatim
    to link Oyranos into your application.

    For C++ make shure you use the oyranos:: namespace.

 */
/*    - @ref device_profiles - profiles which characterise devices */

/** @page concepts Concepts

    The here described concepts are targeted until version 1.0 of Oyranos.
    They are intended to make the API consistent and its usage predictable.
    A additional page shall describe the behaviour of Oyranos, default settings
    and recommendations to developers who like to interact with the system.

    @subsection os_concept Interoperatibility on Operating Systems
    - Oyranos is intended to work on Posix systems and at least Windows.
    - On Linux the <a href="http://elektra.sf.net">Elektra</a> configuration
      library is used for managing and storing the configuration.
    - If publically available, Oyranos will sit on top of native Colour
      Management Systems like ColorSync&copy; or ICM&copy;.

    @subsection path_concept Paths Configuration
    - see <a href="http://www.oyranos.org/wiki/index.php?title=OpenIccDirectoryProposal">OpenIccDirectoryProposal at ColourWiki</a>

    @subsection rights_concept Personality
    - Users configure their own settings, while administrators 
      configure system wide settings.
    - User settings have priority over system settings
    - All settings, called policy as a whole, shall be saveable and recoverable.

    @subsection modul_concept Extensibility
    - Register new capabilities and modules will help to build a flexible base
      for further extensions.
    - Therefore the internal data must be kept almost dynamic.
    - Functions are needed, which show useful informations for GUIs, about the
      content in the profiles and about possible errors.
    - Some descriptors are provided as strings, and may help keeping 
      the user interface consistent throughout toolkits. (translation?)

 */

/** @page coding Coding Conventions

    @section general_c_conventions General
    Oyranos is written in C for portability. All types belonging to its API's
    are prefixed with a <b>oy</b>.\n
    Oyranos objects naming is build after C++ conventions,
    where access to a class member is prefixed with the scope operator. \n
    <i>oyranos::oyClass::oyClassFunction</i>\n
    looks in Oyranos\n
    <i>oyClass_Function</i>. Of course a function specific to a data object 
    needs the object itself as argument, as the this pointer is not available.\n
    Oyranos features a flexible memory management and allows easy integration
    with different memory management strategies.

    @section data_handling Data Handling
    <p>Oyranos uses a mix of different structures. Among them are the basic C
    types, simple C structs and Oyranos managed structs.
    The structs are transparent for compile time typechecking and easy
    debugging at runtime.</p>

    <p>Objects are transparent to allow easier debugging. But be aware to not
    change the private members of Oyranos objects directly. 
    They are marked at end with a underscore <b>_</b>. Use the appropriate 
    functions for each object instead. Otherwise the objects are in danger to
    be handled inadequately.
    </p>

    @section memory_handling Memory Handling
    - For strings, constant pointers to chars are provided whenever possible.
    - For the need of allocating unknown sizes of memory, a function is passed
      by the user doing the memory allocation. The returned memory is then to
      be managed by the user.
    - More complex library allocated memory blocks, like profile name lists,
      can be freed with a Oyranos provided function. They should be encapsulated
      into a Oyranos object.
    - Oyranos objects transport always a allocator. The allocator is possible 
      to set by the user at Object creation time.
    - Objects can contain a user specified deallocator.

    @section  naming_convention Naming Conventions
    Declaration types are distinguishable through the below described naming
    conventions.\n
    A <b>oy</b> prefix is common for all functions, types and enums to
    display a namespace in C.\n
    <b>Functions</b> words are starting upper case, (after the oy prefix)
    <i> oyVersion() </i>\n
    <b>Enums</b> have all letters  written upper case. Words are separated by
                      underscore
      <i>oyOBJECT_TYPE_e</i>\n
    <b>Variables</b> are written lower case and words are separated by underscore.
      <i>file_name</i>\n
    <b>Macros</b> are upper case and start with <b>OY_</b>:
      <i>OY_HAVE_PNG</i>\n
    As one exception some macros are normal named to allow later typing:
      <i>oyChar</i>\n
      Function alike macros are named like normal functions followed by
      a <b>_m</b>:
      <i>oyColourOffset_m()</i>\n
      For enum alike macros it is more appropriate to omit the _M suffix:
      <i>oyTYPE_123A_8</i>\n
    <b>Stucts</b> words start upper case followed by a <b>_s</b>:
      <i>oyProfile_s</i>\n
    <b>Struct/object handling functions</b> start upper case with the struct
    name, followed with the verb:
      <i>oyProfile_GetChannelName</i>\n

    @subsection  suffixes  Declaration Overview
    - <b>_t</b> types
    - <b>_s</b> structs
    - <b>_e</b> enums
    - <b>_M</b> or <b>_m</b> or none for macro functions
    - ending underscore <b>_</b> for non editable internals
    - The namespace in C++ is <b>oyranos::</b>\n
      <i>oyranos::oyVersion()</i>


    @section development Development Conventions

    @subsection api_design API Design
    Oyranos API's handle various tasks. A important idea is to make colour 
    management easy. Thus some API's are high level and only a few calls
    are needed to do the, hopefully, right thing. For finer control
    many low level API's are exposed.\n
    It is as well possible to reimplement the Oyranos functionality. Some
    recommendations or standards are therefore provided at OpenICC. Feel free
    to contact the Oyranos project to discuss further details.\n
    Internal API's handle low level file access, internal static lists and
    adapt to backends.

    @subsection object_design Object Design
    All Oyranos structs have a first member called <i>type_</i> to better 
    distinguish them. The according value is available as a enum from
    oyOBJECT_TYPE_e.\n
    The second member of a Object style struct is <i>oy_</i> and features common
    properties, like memory management, naming and more.\n
    A new simple Oyranos data data structure should contain the type_ specifier.
    Complex data structures should contain the type_ and oy_ structure to allow
    the advanced features.\n
    Providing of similiar functions for different Oyranos Objects, allows
    theire use in a abstract way. A soft typecheck is possible over the type_ 
    member. For a example see the internal oyPointerList_ struct with the 
    according C API. As casting in C is always blind, it is better to avoid, 
    except you know what you do. Exposing seems not appropriate.
    For instance, each object should implement a appropriate Release and Copy 
    function with the same shape, arguments and return value, to easily cast
    to functions of other objects providing similiar functionality.
    Thus each object can implement list functionality with a common base in the
    above mentioned oyPointerList_. The resoning behind the above outlined use
    of common API's is, even with C casting, they help in reducing code size, 
    for easier maintaining and while fixing bugs.

    @subsection api_naming API Naming
    Keeping API members in a lexical relation allowes
    for later easy searching with tools of choice. So you find rather a 
    getOyNamedColourName but oyNamedColour_GetName and can easily find the  
    related functions in the appropriate NamedColour API. The sheme follows
    C++ syntax: (namespace)oy(ranos)::(class)NamedColour::(function)getName.
    This should as well help in designing OO wrappers to allow consistency among
    C Oyranos and its wrappers for various languages.

 */

/** @page proposal Proposal
    @section proposal Proposals
    @subsection identity_proposal Profile Identity Proposal
    One major benefit if a configuration system is the ashurance to use the
    correct profiles.\n
    A recently closed flaw in the ICC spec was a missing
    identification tag inside the profile. While profiles may have varaying
    names and descriptions, the now in the ICC standard included md5 checksum
    approach fits well in the demand of easily and relyable distinguish between
    various profiles.\n
    The plan is to check or possibly recalculate the md5 sum and modify the
    profile in the header accordingly. This makes sense especially for older
    profiles. This feature makes of course only sense of the file access is
    resonably quick. A hash table may help here.\n

    @subsection correlation_proposal Correlation Proposal
    An other toppic is the correlation of device and program settings during
    image production and the selection of the correct profile for the needed
    conversions. The profile should allways fit to the tool chain used. 
    My suggestion is here to embedd these settings in a easy recoverable
    way into the profile. A special ascii tag could be used therefor.\n
    External libraries like sane or cups should tell Oyranos theyre
    settings and query for a suitable profile. In the case of a not finding a
    fitting profile the external library may ask for an alternative list of
    settings. With selecting the desired settings the profile can be selected.
    The goal herein is to give the user the freedom of choice and the security
    regarding quality.

    More proposals and ideas can be found on http://www.behrmann.name in the
    Oyranos section.
 */

/** @page install_current Installation

    @section install Installation
    Oyranos depends on following libraries:\n

    <ul>
    <li><a href="http://elektra.sf.net">Elektra</a>, this is the configuration backend for linux , <a href="http://sourceforge.net/project/showfiles.php?group_id=117521">version 0.6.4</a> is needed due to API changes . </li>
    <li><a href="http://www.fltk.org">fltk</a> version >= 1.1.4 needed for a user interface\n
    you may configure fltk with several options enabled\n
    --enable-threads is needed for threads support (in ICC Examin)\n
    --enable-xft is ok for antialiased fonts\n
    --enable-debug is generally a good choice\n
    --enable-shared is sometimes a good choice for smaller executables</li>
    <li><a href="http://www.etg.e-technik.uni-erlangen.de/web/doe/xcalib/">Xcalib</a> for loading a given  VideoCardGammaTag from profile to a running XFree86/Xorg session (optionally)</li>
    </ul>\n
    For building unpack the tgz file and type #make; make install.\n\n
    Optionally you can specifiy an other than the default prefix /opt/local by typing:\n
    #configure.sh --prefix=/what/you/like\n
    #make\n
    #make install   (optionally)\n
 */

/** @page links References
    @section links Links
    - cross platform colour information exchange standard, called ICC - http://www.color.org
    - OpenICC: http://www.freedesktop.org/wiki/OpenIcc
    - Email list: http://lists.freedesktop.org/mailman/listinfo/openicc
    - Oyranos project page: http://www.oyranos.org/wiki
    - Oyranos wiki: http://www.oyranos.org/wiki/index.php?title=Oyranos
    - Elektra, configuration engine used on Linux - http://elektra.sf.net
    - Xcalib, a vcgt to window server uploader - http://www.etg.e-technik.uni-erlangen.de/web/doe/xcalib/
    - Directory paths for colour profiles and other configuration data <a href="http://www.oyranos.org/wiki/index.php?title=OpenIccDirectoryProposal">OpenIccDirectoryProposal at ColourWiki</a>
    - X11 Requirements http://www.oyranos.org/wiki/index.php?title=Oyranos_X11_Requirements
 */

/** @file oyranos.h
    @brief The API header for general users to include in your application.
    
    This file contains all functions and structs available in the Oyranos API.\n
    For further macros see @file oyranos_definitions.h\n
    For the Oyranos Monitor API see @file oyranos_monitor.h
*/

/** @file oyranos_definitions.h
    @brief The macro header to include in your application without using any Oyranos function.
    
    This file contains all macros which are relevant to the Oyranos API using
    the Elektra library as configuration engine.\n
    For the Oyranos API see @file oyranos.h\n
    @see Elektra at sourceforge <a href="http://elektra.sf.net">Elektra</a>
*/

/** @file oyranos_monitor.h
    @brief The Monitor API header to include in your application.
    
    This file contains all functions and structs available in the Oyranos Monitor API.\n
    @see oyranos_definitions.h for Elektra macros\n
    @see oyranos.h for the Oyranos API
*/

/** @file oyranos_config.h
    @brief The API header for adminitrative users to include in configuration 
           dialogs.
    
    @see oyranos.h for the non administrative Oyranos API
*/

/** @file oyranos.c
    @brief The API implementation
    
    This file contains functions implementing the Oyranos API.\n
    For the Oyranos API see @file oyranos.h
*/

/** @file oyranos_monitor.c
    @brief The Monitor API implementation
    
    This file contains functions implementing the Oyranos Monitor API.\n
    For the Oyranos Monitor API see @file oyranos_monitor.h\n
    For the Oyranos API see @file oyranos.h
*/

/** @file oyranos_gamma.c
    @brief A small helper for setting up Oyranos at the window server
           start time.
    
    This helper searches for the appropriate monitor profile in the Oyranos 
    Deviceprofiles database. If found it tells the window server about it and
    loads a possibly available VideoCardGammaTable tag into the running session.
    It uses the Oyranos Monitor API from @file oyranos_monitor.h
*/


