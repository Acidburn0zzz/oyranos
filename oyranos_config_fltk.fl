# data file for the Fltk User Interface Designer (fluid)
version 1.0107 
i18n_type 1 
i18n_include <libintl.h> 
i18n_function _ 
header_name {.h} 
code_name {.cxx}
decl {\#include <FL/Fl_Choice.H>} {public
} 

decl {\#include <FL/Fl_Box.H>} {public
} 

decl {\#include <FL/Fl_Button.H>} {public
} 

decl {\#include <FL/Fl_File_Chooser.H>} {public
} 

decl {\#include <FL/Fl_Output.H>} {public
} 

decl {\#include <FL/Fl_Pack.H>} {public
} 

decl {\#include <FL/fl_ask.H>} {public
} 

decl {\#include <FL/fl_draw.H>} {public
} 

decl {\#include "oyranos.h"
\#include "oyranos_debug.h"
\#include "oyranos_config.h"
\#include "config.h"} {public
} 

decl {\#include "fl_i18n/fl_i18n.H"} {public
} 

decl {\#include <iostream>} {public
} 

decl {\#include <fstream>} {public
} 

decl {\#include <cstdio>} {public
} 

decl {using namespace oyranos;} {public
} 

decl {\#define H_SPACING 10} {public
} 

decl {\#define V_SPACING 3} {public
} 

decl {\#define BUTTON_HEIGHT 25} {public
} 

decl {\#define BOX_WIDTH 250
\#define SELECT_WIDTH 176} {public
} 

Function {myAllocFunc(size_t size)} {private return_type {void*}
} {
  code {return new char [size];} {}
} 

Function {setPolicy( int i )} {} {
  code {printf( "Option = %d\\n", i );

  char* data = 0;
  const char *filename = 0;

  int count;
  const char **policies_list = getPolicies( &count );
  filename = policies_list[2*i+1];

  {
    printf("%s\\n", filename);
    std::ifstream f( filename, std::ios::binary | std::ios::ate);
    if(f.good())
    {
      size_t size = f.tellg();
      f.seekg(0);
      if(size) {
        data = (char*) new char [size+1];
        f.read ((char*)data, size);
        f.close();
        printf( "Opened file: %s\\n", filename );
      }
    }
  }

  char *xml = data;

  if(xml) {
    oyranos::oyPathsCount();
    oyranos::oyReadXMLPolicy(oyranos::oyGROUP_ALL, xml);
    printf("xml text: \\n%s", xml);
    delete [] xml;
  } else
    printf("No policy file found: \\"%s\\"!!!\\n", filename);

  updateUI();} {}
} 

Function {getPolicyName()} {open return_type {const char*}
} {
  code {int count = 0;
  const char** policy_list = getPolicies( &count );
  const char *name = _("[none]");

  oyI18NSet(0,0);
  char *xml = oyPolicyToXML (oyGROUP_ALL, 0, myAllocFunc);
  oyI18NSet(1,0);
  xml[strlen(xml)-2] = 0;
  std::cout << xml <<std::endl;

  for( int i = 0; i < count; ++i )
  {

    char *data = 0;

    const char* fname = policy_list[2*i+1];
    std::ifstream f( fname, std::ios::binary | std::ios::ate);
    if(f.good())
    {
      size_t size = f.tellg();
      f.seekg(0);
      if(size) {
        data  = (char*) new char [size+100];
        f.read ((char*)data, size);
        data[size]=0;
        f.close();
      }
    }

    if( !data )
      std::cout << "no policy files available" << std::endl;
    else if( !xml )
      std::cout << "no policy data available??" << std::endl;
    else if( strstr( data, xml ) )
      name = policy_list[i*2+0];

    if(data) delete [] data;
  }
  if(xml)  delete [] xml;

  return name;} {selected
  }
} 

Function {getPolicies( int *count )} {return_type {const char**}
} {
  code {static const char *policy_list[8] = {

  "Office + Home", OY_SYSCOLORDIR OY_SLASH OY_SETTINGSDIRNAME OY_SLASH "office.policy.xml",
  "Graphic Designers", OY_SYSCOLORDIR OY_SLASH OY_SETTINGSDIRNAME OY_SLASH     "designer.policy.xml",
  "PrePress", OY_SYSCOLORDIR OY_SLASH OY_SETTINGSDIRNAME OY_SLASH    "prepress.policy.xml",
  "Photographers", OY_SYSCOLORDIR OY_SLASH OY_SETTINGSDIRNAME OY_SLASH "photographer.policy.xml"
  };

  for(int i = 0; i < 8; ++i)
    policy_list[i*2] = _(policy_list[i*2]);

/*  FILE *pp = popen( "oyranos-config --syscolordir", "r" );
  if (!pp) {
    perror ("oyranos-config not found");
    return -1;
  }
  char sname[1024];
  if (fscanf (pp, "%s", &sname) != 1) {
    pclose (pp);
    printf ("oyranos-config did not correctly respond");
    return 0;
  }
  pclose( pp );

  pp = popen( "oyranos-config --syscolordir", "r" );
  char settingsname[128];
  if (fscanf (pp, "%s", &settingsname) != 1) {
    pclose (pp);
    printf ("oyranos-config did not correctly respond");
    return 0;
  }
  pclose( pp );

  char path[1024];
  snprintf( filename, 1023, "%s/%s/%s", sname, settingsname, "office.policy.xml" );
 */
  *count = 4;
  return policy_list;} {}
} 

Function {selectDefaultProfile_callback( Fl_Widget* w, void* )} {} {
  code {Option *op = dynamic_cast<Option*> (w->parent());
  if(op) {
    Fl_Choice *c = dynamic_cast<Fl_Choice*> (w);
    if(c) {
      std::cout << c->value() << c->text() << std::endl;
      char text[64];
      int error = 0;
      if(strcmp(c->text(),_("[none]")) == 0)
        error = oySetDefaultProfile( (oyDEFAULT_PROFILE)op->option,0);
      else
        error = oySetDefaultProfile( (oyDEFAULT_PROFILE)op->option, c->text());
      if(error) {
        sprintf( text, "%s %s", _("setting"), _("failed!"));
        fl_alert( text );
      } else
        updateUI();

    } else fl_alert( "no Fl_Choice" );
  } else fl_alert( _("Select Profile") );} {}
} 

Function {showDefaultProfile_callback( Fl_Widget* w, void* )} {} {
  code {Option *op = dynamic_cast<Option*> (w->parent());
  if(op) {
    {
      char text[64];
      char *pn = oyGetDefaultProfileName( (oyDEFAULT_PROFILE)op->option, myAllocFunc);
      if(!pn) {
        sprintf(text, "%s %s", _("showing"), _("failed!") );
        fl_alert( text );
      } else {
        char command[1024];
        snprintf( command, 1024, "export PATH=$PATH:" OY_BINDIR "; iccexamin \\"%s%s%s\\"&",
                  oyGetPathFromProfileName( pn, myAllocFunc ), OY_SLASH, pn );
\#      ifdef DEBUG_
          fprintf(stderr, "%s\\n", command);
\#      endif
        int r = system( command );
        if(r >= 0x200) {
          fl_alert( _("Show Profile failed. iccexamin not found") );
          fprintf(stderr, "%s:%d command \\"%s\\" failed with error: %d.\\n",
                  __FILE__,__LINE__, command, r);
        }
      }
    }
  } else fl_alert( _("Show Profile failed") );} {}
} 

Function {addPathCallback( Fl_Widget* w, void* )} {} {
  code {char* name = fl_dir_chooser(_("Select a directory with ICC profiles"), NULL);
  if( name ) {
    oyPathAdd ( name );
    updateUI();
  }} {}
} 

Function {rmPathCallback( Fl_Widget* w, void* )} {} {
  code {ProfilePath *pp = dynamic_cast<ProfilePath*> (w->parent());
  if(pp) {
    Fl_Button *b = dynamic_cast<Fl_Button*> (w);
    if(b && b == pp->button_add) {
      std::cout << b->value() << std::endl;
      char text[512];
      int error = oyPathAdd (pp->box->label());
      if(error) {
        sprintf(text, _("error setting path: %s"), pp->box->label());
        fl_alert( text );
      }
    } else
    if(b && b == pp->button_remove) {
      std::cout << b->value() << std::endl;
      oyPathRemove ( pp->box->label() );
      //Fl::pushed(&bPL);
      updateUI();

      // Alle Blaetter Loeschen
      //removePathLeaves();
      //buildPathLeaves();
      // Nun ist der Speicherblock fuer diese Funktion bereits freigegeben
      // und wird aber weiter benutzt
    } else fl_alert( "no Fl_Button" );
  } else fl_alert( _("Path") );} {}
} 

Function {selectBehaviourCallback( Fl_Widget* w, void* x )} {} {
  code {Option *op = dynamic_cast<Option*> (w->parent());
  if(op) {
    Fl_Choice *c = dynamic_cast<Fl_Choice*> (w);
    if(c) {
      std::cout << (intptr_t)x << c->user_data() << c->value() << c->text() << std::endl;
      char text[64];
      int error = 0;
      error = oySetBehaviour( (oyBEHAVIOUR)op->option, c->value());
      if(error) {
        sprintf(text, "%s %s %s", _("setting"), _("failed!"),
                c->text());
        fl_alert( text );
      } else
        updateUI();
    } else fl_alert( "no Fl_Choice" );
  } else fl_alert( _("Select Behaviour") );} {}
} 

Function {debug_me( )} {} {
  code {
  int nonsense = 0;
  ++nonsense;
  } {}
} 

class OyFlPack {: {public Fl_Pack}
} {
  Function {OyFlPack(int x, int y, int w, int h , const char *t = 0) : Fl_Pack(x,y,w,h,t)} {} {
    code {} {}
  }
  Function {draw()} {open private
  } {
    code {int nw = 0;
  //int X=x(),Y=y(),W=w(),H=h();
  if( dynamic_cast <Fl_Scroll*> (parent()) )
  {
    nw = parent()->w() - Fl::box_dw( parent()->box() ) - BUTTON_HEIGHT;
    ///size( nw, Fl_Pack::h() );
  } else {
    nw = parent()->w() - Fl::box_dw( parent()->box() );
  }
  w( nw );


  //nh = parent()->h() - Fl::box_dh( parent()->box() );
  /*if( horizontal() )
    Fl_Pack::size( nw, Fl_Pack::h() );
  else
    Fl_Pack::size( Fl_Pack::w(), nh );
  */

  // prearrange if one widget is resizeable
  Fl_Widget *re = resizable();
  if( re )
  {
    int n = children();
    int pos_x = Fl::box_dx(box()) + spacing(),
        pos_y = Fl::box_dy(box()) + spacing(),
        pos_w = w() - Fl::box_dw(box()) - spacing(),
        pos_h = h() - Fl::box_dh(box()) - spacing();
    int re_n = 0;
    
    for( int i = 0; i < n; ++i )
    {
      Fl_Widget *o = child( i );
      if( o == re )
      {
        re_n = i;
        break;
      }
      
      if( horizontal() )
      {
        o->position( pos_x, o->y() );
        pos_x += o->w() + spacing();
      } else {
        o->position( o->x(), pos_y );
        pos_y += o->h() + spacing();
      }
    }
    
    for( int i = n - 1; i > re_n; --i )
    {
      Fl_Widget *o = child( i );
      //int X = o->x(), Y = o->y(), W = o->w(), H = o ->h();
      if( horizontal() )
      {
        o->position( pos_w - o->w(), o->y() );
        pos_w -= o->w() + spacing();
      } else {
        o->position( o->x(), pos_h - o->h());
        pos_h -= o->h() + spacing();
      }
    }
    
    if(horizontal())
      re->resize( pos_x, re->y(), pos_w-pos_x, re->h() );
    else
      re->resize( re->x(), pos_y, re->w(), pos_h-pos_y );
  }


  Fl_Pack::draw();} {}
  }
} 

class BoxChoiceCombo {: {public Fl_Pack}
} {
  decl {Fl_Box   *box;} {public
  }
  decl {Fl_Choice*choice;} {public
  }
  Function {BoxChoiceCombo( int x, int y, int w, int h ) : Fl_Pack(x, y, w, h)} {open
  } {}
} 

class Option {: {public OyFlPack} private
} {
  decl {Fl_Box   *box;
  Fl_Choice*choice;

  oyWIDGET option;
  oyWIDGET_TYPE type;
  int       i;} {public
  }
  Function {Option( int x, int y, int w, int h, const char *name,
  oyWIDGET option_,
  oyWIDGET_TYPE type_,
  int choices_n,
  const char **choices,
  int current,
  const char *tooltip) : OyFlPack(x, y, w, h)} {open
  } {
    code {
  Fl_Pack::type( FL_HORIZONTAL );
  Fl_Pack::spacing(H_SPACING);

  option = option_;
  type = type_;

  debug_me();

  // == Profiles ==
  if( type == oyTYPE_DEFAULT_PROFILE || type == oyTYPE_PROFILE )
  {
    int weigth = BOX_WIDTH + SELECT_WIDTH + 4 * H_SPACING + BUTTON_HEIGHT;
    if(w < weigth)
      Fl_Pack::size( weigth, Fl_Pack::h() );

    w = Fl_Pack::w();

    char *title_text = (char*) new char [256];
    sprintf(title_text, _("%s Profile"), name );

    // Profile name box
    box = new Fl_Box( x, y,
                      w - SELECT_WIDTH - BUTTON_HEIGHT - 4*H_SPACING, BUTTON_HEIGHT,
                      name );
    box->tooltip( tooltip );
    box->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);

    if(option == oyWIDGET_ASSUMED_WEB) {
      const char* default_p = NULL;
      if(current >= 0)
        default_p = choices[current];
      if(default_p) {
        DBG_PROG_S( (default_p) )
      } else
        default_p = "";
      if(default_p) {
        box = new Fl_Box( w - BOX_WIDTH - SELECT_WIDTH - BUTTON_HEIGHT - 3*H_SPACING, y,
                          190, BUTTON_HEIGHT, default_p );
        box->align( FL_ALIGN_LEFT | FL_ALIGN_INSIDE );
        Fl_Group::end();
        Fl_Group::resizable( box );
        return;
      }
    }

    // Choice
    choice = new Fl_Choice( w - SELECT_WIDTH - BUTTON_HEIGHT - 2*H_SPACING, y,
                            SELECT_WIDTH, h );
    choice->callback( selectDefaultProfile_callback );
    choice->tooltip( tooltip );
    DBG_PROG_V((choice->size()))
    choice->add( _("[none]") );
    DBG_PROG_V((choice->size()))

    // Profile viewer
    Fl_Button *button = new Fl_Button( w - BUTTON_HEIGHT - H_SPACING, y,
                                       BUTTON_HEIGHT, BUTTON_HEIGHT, "@-3DnArrow" );
    button->callback( showDefaultProfile_callback );
    button->tooltip(_("Show in external Viewer"));

    // Set choice
    const char* default_p = NULL;
      if(current >= 0)
        default_p = choices[current];
    if(default_p) {
      DBG_PROG_S( (default_p) )
    } else
      default_p = "";
    int val = 0, occurence = 0;
    for (i = 0; i < choices_n; ++i)
    {
      choice->add( choices[i] );
      for(int k = 0; k < choices_n; ++k)
        if(strcmp( choices[i], choices[k]) == 0 && 
           strlen( choices[i] ) &&
           i < k )
          printf("Double occurency of profile: %s\\n", choices[i]);


      if(strstr( choices[i], default_p) && 
         strlen( choices[i] ) == strlen(default_p))
      {
        if(val) {
          ++occurence;
        } else {
          val = i+1;
          ++occurence;
        }
      }
    }
    if(occurence > 1)
      WARN_S((_("multiple occurencies of default %s profile: %d times"),
               name, occurence))
    choice->value( val );

    DBG_PROG_V((choice->size()))

    DBG_PROG_V((val))
  }


  // == Behaviour ==
  if( type == oyTYPE_BEHAVIOUR || type == oyTYPE_CHOICE )
  {
    int weigth = BOX_WIDTH + SELECT_WIDTH + 4 * H_SPACING + BUTTON_HEIGHT;
    if(w < weigth)
      Fl_Pack::size( weigth, Fl_Pack::h() );

    w = Fl_Pack::w();

    char *title_text = (char*) new char [256];
    sprintf(title_text, _("%s Profile"), name );

    // Profile name box
    box = new Fl_Box( x, y,
                      w - SELECT_WIDTH - BUTTON_HEIGHT - 4*H_SPACING, BUTTON_HEIGHT,
                      name );
    box->tooltip( tooltip );
    box->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);

    // Choice
    choice = new Fl_Choice( w - SELECT_WIDTH - H_SPACING, y,
                            SELECT_WIDTH + BUTTON_HEIGHT + H_SPACING, h );
    choice->callback( selectBehaviourCallback );
    choice->tooltip( tooltip );

    // Set choice
    for (i = 0; i < choices_n; ++i)
    {
      choice->add( choices[i] );
    }
    choice->value( current );

  }

  
  end();
  resizable( box );} {}
  }
} 

class ProfilePath {: {public Fl_Pack} private
} {
  decl {Fl_Box   *box;
  int       n;
  Fl_Button*button_add, *button_remove;} {public
  }
  Function {ProfilePath( int x, int y, int w, int h, int num )
    : Fl_Pack(x, y, w, h)} {open
  } {
    code {Fl_Pack::type( FL_HORIZONTAL );
    Fl_Pack::spacing(H_SPACING);
    Fl_Group::resizable(0);

    n = num;
    char *name = oyPathName(n, myAllocFunc) ;
    //std::cout << name << std::endl;
    //new Fl_Box( 0, 0, 10, 20 );
    box = new Fl_Box( 0, 0, 10, BUTTON_HEIGHT, name );
    box->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);

    if( strcmp( "/usr/share/color/icc", name ) != 0 &&
        strcmp( "~/.color/icc", name ) != 0 &&
        strcmp( OY_SYSCOLORDIR OY_SLASH OY_ICCDIRNAME , name ) != 0 &&
        strcmp( OY_USERCOLORDIR OY_SLASH OY_ICCDIRNAME, name ) != 0 )
    {
      button_remove = new Fl_Button( 0, 0, BUTTON_HEIGHT, BUTTON_HEIGHT, "@-31+" );
      button_remove->callback( rmPathCallback );
      button_remove->tooltip(_("Exclude this path"));
      new Fl_Box( 0, 0, H_SPACING, 20 );
      printf( "%s : %s\\n", name, OY_SYSCOLORDIR OY_SLASH OY_ICCDIRNAME );
    }
    //printf( "%s ? %s %s %s\\n", name, OY_SYSCOLORDIR, OY_SLASH, OY_ICCDIRNAME );

    int width=0, height=0;
    int scroll_w = 50; //default_profiles_pack->w() - 3*H_SPACING - BUTTON_HEIGHT;

    box->measure_label(width, height);
    int b_w = scroll_w;
    if(width > scroll_w)
      b_w = width;

    box->size( b_w, 20 );
    Fl_Pack::size( b_w + 2*H_SPACING + BUTTON_HEIGHT, Fl_Pack::h() );
    //if(name) delete [] name; // dont delete as it belongs now to the widget
    } {}
  }
} 

Function {refreshPathLeaves()} {private
} {
  code {paths_scroll->clear();

  int count = oyPathsCount();
  if(count < 2)
    count = oyPathsCount();

  paths_scroll->begin();
  
  Fl_Pack *paths_pack = new Fl_Pack( paths_scroll->x(),paths_scroll->y(),10,10 );
  //paths_pack->box( FL_PLASTIC_UP_FRAME );
  
  ProfilePath *pp = 0;
  int width = 0;
  new Fl_Box(0,0,10, H_SPACING);

  for (int i = 0 ; i < count ; ++i) {
    pp = new ProfilePath( paths_scroll->x(), paths_scroll->y(),
                          50, BUTTON_HEIGHT, i );
    if( width < pp->w() )
      width = pp->w();
    pp->end();
  }

  Fl_Pack *pack = new Fl_Pack(0,0,
                              width, BUTTON_HEIGHT);
    pack->type( FL_HORIZONTAL );
    pack->spacing( H_SPACING );
    Fl_Button *nbutton = new Fl_Button(0,0, width-BUTTON_HEIGHT-2*H_SPACING, BUTTON_HEIGHT, _("@-3+"));
    nbutton->callback( addPathCallback );
    nbutton->tooltip(_("Add Path containing ICC profiles"));
    pack->resizable( nbutton );
    new Fl_Box( 0, 0, 1, 20 );
  pack->end();
  
  new Fl_Box(0,0,10, H_SPACING);

  paths_pack->spacing( V_SPACING );
  paths_pack->size( width + 10, paths_pack->h() );
  paths_pack->end();
  paths_scroll->end();
  paths_scroll->redraw();
  std::cout << nbutton->x() << ","<< nbutton->w() <<std::endl;} {}
} 

Function {addTab( Fl_Tabs* tabs, const oyGROUP *groups )} {private return_type {Fl_Group*}
} {
  code {Fl_Group *parent = /*dynamic_cast <Fl_Group>*/ tabs; // parent tab
  Fl_Group *tab = NULL; // actual tab

  if( !parent )
    WARN_S( ("wrong widget") );

  for( int k = 1; k <= groups[0]; ++k )
  {
    int i = 0;
    int wcount = parent->children();
    tab = NULL;

    for( i = 0; i < wcount; ++i )
    {
      const char *g_name = NULL;
      const char *c_name = parent->child( i )->label(); // current name

      oyWidgetTitleGet( (oyWIDGET)groups[k], NULL, &g_name, NULL, NULL );
      if( c_name && g_name )
      if( strcmp( c_name, g_name ) == 0 )
      {
        // a widget with the searched label was found => tab exists allready
        tab = (Fl_Tabs*) parent->child( i );
        tab->box( FL_THIN_UP_BOX );
        break;
      }
    }

    if( !tab )
    {
      const char *tooltip = NULL;
      const char *title = NULL;
      oyWidgetTitleGet( (oyWIDGET)groups[k], NULL, &title, &tooltip, NULL );

      parent->begin();
        Fl_Widget *wid = (Fl_Widget*)parent->user_data();
        if( !wid ) wid = parent;

        int x = parent->x() + Fl::box_dx( wid->box() ) + V_SPACING,
            y = parent->y() + Fl::box_dy( wid->box() ) + BUTTON_HEIGHT,// + V_SPACING,
            w = parent->w() - Fl::box_dw( wid->box() ) - 2*V_SPACING,
            h = parent->h() - Fl::box_dh( wid->box() ) - BUTTON_HEIGHT - 2*V_SPACING;
        if( k < groups[0] )
        {
          tab = new Fl_Tabs(   x,y,w,h, title);
          tab->tooltip( tooltip );
          tab->user_data( tab );
          tab->box( FL_THIN_UP_BOX );
          tab->end();
        } else {
          tab = new Fl_Scroll( x,y,w,h, title );
          tab->tooltip( tooltip );
          tab->box( FL_NO_BOX ); //FL_THIN_UP_BOX );
          { OyFlPack* o = new OyFlPack( tab->x() + Fl::box_dx( tab->box() ) + V_SPACING,
                                        tab->y() + Fl::box_dy( tab->box() ) + V_SPACING,// + BUTTON_HEIGHT,
                                        150,
                                        parent->h() - Fl::box_dh( parent->box() ) - BUTTON_HEIGHT );
            o->box( FL_NO_BOX );
            o->spacing( V_SPACING );
            o->end();
            tab->user_data( o );
            tab->resizable( o );
          }
          tab->end();
        }
      parent->end();
      parent->resizable( tab );
    }
    parent = const_cast <Fl_Group*> (dynamic_cast<Fl_Group*>(tab));
  }

  if( tab )
    return (Fl_Group*)tab->user_data();
  else
    return NULL;} {}
} 

Function {getTab( Fl_Tabs* tabs, oyGROUP group, Fl_Group **container )} {private return_type {Fl_Group*}
} {
  code {Fl_Group *parent = /*dynamic_cast <Fl_Group>*/ tabs; // parent tab
  Fl_Group *tab = NULL; // actual tab

  if( container )
    *container = NULL;

  if( !parent )
    WARN_S( ("wrong widget") );

    int wcount = parent->children();
    tab = NULL;

    for( int i = 0; i < wcount; ++i )
    {
      const char *g_name = NULL;
      const char *c_name = parent->child( i )->label(); // current name

      oyWidgetTitleGet( (oyWIDGET)group, NULL, &g_name, NULL, NULL );
      if( c_name && g_name )
      if( strcmp( c_name, g_name ) == 0 )
      {
        tab = (Fl_Tabs*) parent->child( i );
        wcount = tab->children();
        for( i = 0; i < wcount; ++i )
          if( dynamic_cast <Fl_Pack*>( tab->child( i ) ) )
          {
            Fl_Pack *p = dynamic_cast <Fl_Pack*>( tab->child( i ) );
            if( p && p == tab->user_data() )
              *container = p;
            return tab;
          }
        return tab;
      }
    }

  return tab;} {}
} 

Function {refreshOptions()} {private
} {
  code {// remove tabs
  //const char *t = oyGetGroupUITitle( oyGROUP_BEHAVIOUR, NULL );
  Fl_Group   *sg; // sub group
  
  Fl_Group *s = getTab( top_tabs, oyGROUP_BEHAVIOUR, &sg );
  if( s )
  {
    top_tabs->remove( s );
    delete s;
  }
  
  s = getTab( top_tabs, oyGROUP_DEFAULT_PROFILES, &sg );
  if( s )
  {
    top_tabs->remove( s );
    delete s;
  }


  top_tabs->damage( FL_DAMAGE_ALL );
  top_tabs->redraw();


  Option *op = 0;

  int n = 0;
  oyWIDGET *wl = oyWidgetListGet( oyGROUP_ALL, &n );

  // fill in all the options
  for( int i = 0 ; i < n ; ++i )
      {
        const oyGROUP * groups;
        int             count = 0,
                        current = 0,
                        flags = 0;
        const char    * tooltip = NULL;
        const char   ** names = NULL;
        const char    * name = NULL;
        oyWIDGET_TYPE   type = oyWidgetTitleGet(  wl[i],
                                                  &groups, &name, &tooltip,
                                                  &flags );
        if(type == oyTYPE_CHOICE ||
           type == oyTYPE_BEHAVIOUR ||
           type == oyTYPE_DEFAULT_PROFILE ||
           type == oyTYPE_PROFILE)
        {
          Fl_Group *w = addTab( top_tabs, groups );

          oyOptionChoicesGet( wl[i], &count, &names, &current );
          /*for(int en = 0; en < count; ++en)
            printf("%s\\n", names[en]);*/

          if(w)
          { w->begin();
              op = new Option( w->x(), w->y(), Fl_Group::current()->w(),
                         BUTTON_HEIGHT, name,
                         wl[i], type, count, names, current, tooltip );
            w->end();
          }
        }
      }

  // resize the top group
  if( op )
  {
    int tw = top_group->w(),
        ow = op->w();
    if( tw < ow )
      top_group->size( ow, top_group->h() );
  }

  } {}
} 

Function {createUI()} {} {
  code {oyPathsCount();
  int count;
  const char **policies_list = getPolicies( &count );

  menu_policy_choice[0].label (policies_list[2*0+0]);
  menu_policy_choice[1].label (policies_list[2*1+0]);
  menu_policy_choice[2].label (policies_list[2*2+0]);
  menu_policy_choice[3].label (policies_list[2*3+0]);

  top_tabs->clear();
  
  top_tabs->begin();

  // Create first tab for policies
  const char *actual_policy = getPolicyName();
  Fl_Group *g = NULL;
      { const char *tooltip = 0;
        const char *name = NULL;
        int flags = 0;
        oyWidgetTitleGet( oyWIDGET_GROUP_POLICY, NULL, &name, &tooltip, &flags);
        Fl_Group* o = g = new Fl_Group(10, 101, 485, 260, name);
        o->tooltip( tooltip );
        { Fl_Pack* o = new Fl_Pack(10, 101, 485, 256);
          { //Fl_Box* o = 
            new Fl_Box(25, 150, 25, 25);
          }
          { Fl_Choice* o = policy_choice = new Fl_Choice(14, 115, 196, 25);
            o->box(FL_NO_BOX);
            o->down_box(FL_BORDER_BOX);
            o->menu(menu_policy_choice);
          }
          { Fl_Box* o = new Fl_Box(25, 150, 25, 25);
            Fl_Group::current()->resizable(o);
          }
          o->box( FL_NO_BOX );
          o->end();
        }
        o->box( FL_FLAT_BOX );
        o->end();
        Fl_Group::current()->resizable(o);
      }
      { const char *tooltip = 0;
        const char *name = NULL;
        int flags = 0;
        oyWidgetTitleGet( oyWIDGET_GROUP_PATHS, NULL, &name, &tooltip, &flags );
        Fl_Group* o = g = new Fl_Group(10, 95, 485, 266, name);
        o->tooltip( tooltip );
        o->box( FL_NO_BOX );
        o->hide();
        { Fl_Scroll* o = paths_scroll = new Fl_Scroll(10, 100, 490, 261);
          o->box( FL_NO_BOX );
          o->end();
        }
        o->end();
      }

  top_tabs->end();


  for( int i = 0; i < count; ++i )
  {
    if( strstr( policies_list[2*i+0], actual_policy ) )
      policy_choice->value( i );
      policy_box->label( actual_policy );
  }

  refreshOptions();
  //listWindow(top_tabs);
  refreshPathLeaves();
  //listWindow(top_tabs);} {}
} 

Function {updateUI()} {} {
  code {
  //! \internal@todo start refreshing when the UI has finished

  Fl::add_idle(updateUIIdle);} {}
} 

Function {updateUIIdle(void*)} {} {
  code {
  Fl::remove_idle(updateUIIdle);
  //! \internal refreshing when the UI has finished
  refreshOptions();
  refreshPathLeaves();

  policy_box->label( getPolicyName() );
  } {}
} 

Function {} {C
} {
  code {Fl::scheme("plastic");

  const char *locale_paths[3] = {0,0,0};
  signed int is_path = -1;
  int num_paths = 0;
\# if __APPLE__
  std::string bdr;
  // RESOURCESPATH is set in the bundle by "Contents/MacOS/ICC Examin.sh"
  if(getenv("RESOURCESPATH")) {
    bdr = getenv("RESOURCESPATH");
    bdr += "/locale";
    locale_paths[num_paths] = bdr.c_str(); ++num_paths;
  }
  if(!locale_paths[0]) {
    //bdr = icc_examin_ns::holeBundleResource("locale","");
    if(bdr.size())
    {
      locale_paths[num_paths] = bdr.c_str();
      ++num_paths;
    }
  }
  locale_paths[num_paths] = OY_LOCALEDIR; ++num_paths;
  locale_paths[num_paths] = OY_SRC_LOCALEDIR; ++num_paths;
\# else
  locale_paths[0] = OY_LOCALEDIR; ++num_paths;
\#ifdef WIN32
\#define DIR_SEPARATOR_C '\\\\'
\#define DIR_SEPARATOR "\\\\"
\#else
\#define DIR_SEPARATOR_C '/'
\#define DIR_SEPARATOR "/"
\#endif
  //DBG_NUM_V(( argc <<" "<< argv[0] )
  if (argc)
  { const char *reloc_path = {"../share/locale"};
    int len = (strlen(argv[0]) + strlen(reloc_path)) * 2 + 128;
    char *path = (char*) malloc( len ); // small one time leak
    char *text = (char*) malloc( len );
    text[0] = 0;
    // whats the path for the executeable ?
    snprintf (text, len-1, argv[0]);
    if (strrchr(text, DIR_SEPARATOR_C)) {
      char *tmp = strrchr(text, DIR_SEPARATOR_C);
      *tmp = 0;
    } else {
      FILE *pp = NULL;

      if (text) free (text);
      text = (char*) malloc( 1024 );

      // Suche das ausfuehrbare Programm
      // TODO symbolische Verknuepfungen
      snprintf( text, 1024, "which %s", argv[0]);
      pp = popen( text, "r" );
      if (pp) {
        if (fscanf (pp, "%s", text) != 1)
        {
          pclose (pp);
          WARN_S(( "no executeable path found" ));
        }
      } else {
        WARN_S(( "could not ask for executeable path" ));
      }
    }
    snprintf (path, len-1, "%s%s%s",text,DIR_SEPARATOR,reloc_path);
    locale_paths[1] = path; ++num_paths;
    locale_paths[2] = OY_SRC_LOCALEDIR; ++num_paths;
    //DBG_NUM_V( path );
    if (text) free (text);
  } else {
    locale_paths[1] = OY_SRC_LOCALEDIR; ++num_paths;
  }
\# endif
  is_path = fl_search_locale_path (num_paths, locale_paths, "de", "oyranos");

  if(is_path >= 0) {
    fl_initialise_locale ( "oyranos", locale_paths[is_path], 1 );
  }} {}
  Fl_Window top_group {
    label {Oyranos Configuration} open
    xywh {50 585 505 410} type Double resizable size_range {305 255 0 0} visible
  } {
    Fl_Pack {} {open
      xywh {0 0 480 70} type HORIZONTAL
    } {
      Fl_Box {} {
        image {oyranos_logo.png} xywh {0 0 85 70} align 16
      }
      Fl_Box {} {
        label {Oyranos Configuration }
        xywh {95 0 385 70} labeltype ENGRAVED_LABEL labelsize 18 align 24 resizable
        code0 {o->redraw();}
      }
    }
    Fl_Tabs top_tabs {open
      xywh {0 70 505 301} resizable
    } {
      Fl_Group {} {
        label Policy open
        tooltip {Reset to a standard Policy for Oyranos.} xywh {10 95 485 266} resizable
      } {
        Fl_Pack {} {open
          xywh {10 105 485 256}
        } {
          Fl_Box {} {
            xywh {30 180 25 25}
          }
          Fl_Choice policy_choice {open
            xywh {30 155 196 25} box NO_BOX down_box BORDER_BOX
          } {
            MenuItem {} {
              label {Office + Home}
              callback {setPolicy( 0 );}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label {Graphic Designers}
              callback {setPolicy( 1 );}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label PrePress
              callback {setPolicy( 2 );}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label Photographers
              callback {setPolicy( 3 );}
              xywh {15 15 100 20}
            }
          }
          Fl_Box {} {
            xywh {40 190 25 25} resizable
          }
        }
      }
      Fl_Group {} {
        label Paths open
        tooltip {Configure Paths} xywh {10 95 485 266} hide
      } {
        Fl_Scroll paths_scroll {open
          xywh {10 100 485 261}
        } {}
      }
    }
    Fl_Button {} {
      label {@-3reload}
      callback {//Fl::pushed(&bPL);
  updateUI();}
      tooltip Refresh xywh {10 375 50 25} when 6
    }
    Fl_Pack {} {open
      xywh {160 371 255 35} type HORIZONTAL
    } {
      Fl_Box {} {
        label {Active Policy:}
        xywh {160 371 120 35} align 24
      }
      Fl_Box policy_box {
        label {----}
        xywh {280 371 135 35} align 20
      }
    }
  }
  code {createUI();} {}
} 

Function {listWindow( Fl_Widget *w )} {} {
  code {Fl_Group *g = dynamic_cast <Fl_Group*> (w);

  static int level = 0;


  if( g )
  {
    int n = g->children();

    std::cout << std::endl;
    for(int i = 0; i < level; ++i) std::cout << " ";

    std::cout << "Group t" << (int)w->type() << " " << w->parent()<<"|"<< w << " " << w->x()<<"+"<<w->y()<<"+"<<w->w()<<"x"<<w->h() <<
                 " \\"" << (w->label()?w->label():"") << "\\":";

    ++level;
    for( int i = 0; i < n; ++i )
    {
      listWindow( g->child(i) );
    }
    --level;
    std::cout << std::endl;
  } else
  {
    std::cout << " t" << (int)w->type() << " " << w->parent()<<"|"<< w << " " << w->x()<<"+"<<w->y()<<"+"<<w->w()<<"x"<<w->h() <<
                 " " << (w->label()?w->label():"- ");
  }} {}
} 
