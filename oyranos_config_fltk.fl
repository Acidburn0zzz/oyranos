# data file for the Fltk User Interface Designer (fluid)
version 1.0107 
header_name {.h} 
code_name {.cxx}
decl {\#include <FL/Fl_Choice.H>} {public
} 

decl {\#include <FL/Fl_Box.H>} {public
} 

decl {\#include <FL/Fl_Button.H>} {public
} 

decl {\#include <FL/Fl_File_Chooser.H>} {public
} 

decl {\#include <FL/Fl_Output.H>} {public
} 

decl {\#include <FL/Fl_Pack.H>} {public
} 

decl {\#include <FL/fl_ask.H>} {public
} 

decl {\#include <FL/fl_draw.H>} {public
} 

decl {\#include "oyranos.h"
\#include "oyranos_debug.h"
\#include "oyranos_config.h"} {public
} 

decl {\#include <iostream>} {public
} 

decl {\#include <fstream>} {public
} 

decl {\#include <cstdio>} {public
} 

decl {using namespace oyranos;} {public
} 

decl {\#define _(text) text} {public
} 

decl {\#define H_SPACING 10} {public
} 

decl {\#define V_SPACING 3} {public
} 

decl {\#define BUTTON_HEIGHT 25} {public
} 

decl {\#define BOX_WIDTH 250
\#define SELECT_WIDTH 176} {public
} 

Function {myAllocFunc(size_t size)} {private return_type {void*}
} {
  code {return new char [size];} {}
} 

Function {setPolicy( int i )} {} {
  code {printf( "Option = %d\\n", i );

  char* data = 0;
  const char *filename = 0;

  int count;
  const char **policies_list = getPolicies( &count );
  filename = policies_list[2*i+1];

  {
    printf("%s\\n", filename);
    std::ifstream f( filename, std::ios::binary | std::ios::ate);
    if(f.good())
    {
      size_t size = f.tellg();
      f.seekg(0);
      if(size) {
        data = (char*) new char [size+1];
        f.read ((char*)data, size);
        f.close();
        printf( "Opened file: %s\\n", filename );
      }
    }
  }

  char *xml = data;

  if(xml) {
    oyranos::oyPathsCount();
    oyranos::oyReadXMLPolicy(oyranos::oyGROUP_ALL, xml);
    printf("xml text: \\n%s", xml);
    delete [] xml;
  } else
    printf("No policy file found: \\"%s\\"!!!\\n", filename);

  updateUI();} {}
} 

Function {getPolicyName()} {return_type {const char*}
} {
  code {int count = 0;
  const char** policy_list = getPolicies( &count );
  const char *name = _("[none]");

  for( int i = 0; i < count; ++i )
  {
    char *xml = oyPolicyToXML (oyGROUP_ALL, 0, myAllocFunc);
    char *data = 0;

    const char* fname = policy_list[2*i+1];
    std::ifstream f( fname, std::ios::binary | std::ios::ate);
    if(f.good())
    {
      size_t size = f.tellg();
      f.seekg(0);
      if(size) {
        data  = (char*) new char [size+100];
        f.read ((char*)data, size);
        data[size]=0;
        f.close();
      }
    }
    xml[strlen(xml)-2] = 0;

    if( strstr( data, xml ) )
      name = policy_list[i*2+0];

    if(data) delete [] data;
    if(xml)  delete [] xml;
  }

  return name;} {}
} 

Function {getPolicies( int *count )} {return_type {const char**}
} {
  code {static const char *policy_list[8] = {

  "Office + Home", "/usr/share/color/settings/office.policy.xml",
  "Graphic Designers",      "/usr/share/color/settings/designer.policy.xml",
  "PrePress",      "/usr/share/color/settings/prepress.policy.xml",
  "Photographers",  "/usr/share/color/settings/photographer.policy.xml"
  };

  *count = 4;
  return policy_list;} {}
} 

Function {selectDefaultProfile_callback( Fl_Widget* w, void* )} {} {
  code {Option *op = dynamic_cast<Option*> (w->parent());
  if(op) {
    Fl_Choice *c = dynamic_cast<Fl_Choice*> (w);
    if(c) {
      std::cout << c->value() << c->text() << std::endl;
      char text[64];
      int error = 0;
      if(strcmp(c->text(),_("[none]")) == 0)
        error = oySetDefaultProfile( (oyDEFAULT_PROFILE)op->type,0);
      else
        error = oySetDefaultProfile( (oyDEFAULT_PROFILE)op->type, c->text());
      if(error) {
        sprintf( text, "%s %s %s", _("setting"), _("failed!"),
                 oyGetOptionUITitle( op->type, NULL, NULL, NULL, NULL) );
        fl_alert( text );
      } else
        updateUI();

    } else fl_alert( "no Fl_Choice" );
  } else fl_alert( _("Select Profile") );} {}
} 

Function {showDefaultProfile_callback( Fl_Widget* w, void* )} {} {
  code {Option *op = dynamic_cast<Option*> (w->parent());
  if(op) {
    {
      char text[64];
      char *pn = oyGetDefaultProfileName( (oyDEFAULT_PROFILE)op->type, myAllocFunc);
      if(!pn) {
        sprintf(text, "%s %s %s", _("showing"), _("failed!"),
                 oyGetOptionUITitle( op->type,
                                       NULL, NULL, NULL, NULL) );
        fl_alert( text );
      } else {
        char command[1024];
        snprintf( command, 1024, "iccexamin \\"%s%s%s\\"&",
                  oyGetPathFromProfileName( pn, myAllocFunc ), OY_SLASH, pn );
        system( command );
      }
    }
  } else fl_alert( _("Show Profile failed") );} {}
} 

Function {addPathCallback( Fl_Widget* w, void* )} {} {
  code {char* name = fl_dir_chooser(_("Select a directory with ICC profiles"), NULL);
  if( name ) {
    oyPathAdd ( name );
    updateUI();
  }} {}
} 

Function {rmPathCallback( Fl_Widget* w, void* )} {} {
  code {ProfilePath *pp = dynamic_cast<ProfilePath*> (w->parent());
  if(pp) {
    Fl_Button *b = dynamic_cast<Fl_Button*> (w);
    if(b && b == pp->button_add) {
      std::cout << b->value() << std::endl;
      char text[512];
      int error = oyPathAdd (pp->box->label());
      if(error) {
        sprintf(text, "error setting path: %s", pp->box->label());
        fl_alert( text );
      }
    } else
    if(b && b == pp->button_remove) {
      std::cout << b->value() << std::endl;
      oyPathRemove ( pp->box->label() );
      //Fl::pushed(&bPL);
      updateUI();

      // Alle Blaetter Loeschen
      //removePathLeaves();
      //buildPathLeaves();
      // Nun ist der Speicherblock fuer diese Funktion bereits freigegeben
      // und wird aber weiter benutzt
    } else fl_alert( "no Fl_Button" );
  } else fl_alert( "Path" );} {}
} 

Function {selectBehaviourCallback( Fl_Widget* w, void* x )} {} {
  code {Option *op = dynamic_cast<Option*> (w->parent());
  if(op) {
    Fl_Choice *c = dynamic_cast<Fl_Choice*> (w);
    if(c) {
      std::cout << (int)x << c->user_data() << c->value() << c->text() << std::endl;
      char text[64];
      int error = 0;
      error = oySetBehaviour( (oyBEHAVIOUR)op->type, c->value());
      if(error) {
        sprintf(text, "%s %s %s", _("setting"), _("failed!"),
                c->text());
        fl_alert( text );
      } else
        updateUI();
    } else fl_alert( "no Fl_Choice" );
  } else fl_alert( _("Select Behaviour") );} {}
} 

class OyFlPack {: {public Fl_Pack}
} {
  Function {OyFlPack(int x, int y, int w, int h , const char *t = 0) : Fl_Pack(x,y,w,h,t)} {} {
    code {} {}
  }
  Function {draw()} {open private
  } {
    code {int nw = 0;
  //int X=x(),Y=y(),W=w(),H=h();
  if( dynamic_cast <Fl_Scroll*> (parent()) )
  {
    nw = parent()->w() - Fl::box_dw( parent()->box() ) - BUTTON_HEIGHT;
    ///size( nw, Fl_Pack::h() );
  } else {
    nw = parent()->w() - Fl::box_dw( parent()->box() );
  }
  w( nw );


  //nh = parent()->h() - Fl::box_dh( parent()->box() );
  /*if( horizontal() )
    Fl_Pack::size( nw, Fl_Pack::h() );
  else
    Fl_Pack::size( Fl_Pack::w(), nh );
  */

  // prearrange if one widget is resizeable
  Fl_Widget *re = resizable();
  if( re )
  {
    int n = children();
    int pos_x = Fl::box_dx(box()) + spacing(),
        pos_y = Fl::box_dy(box()) + spacing(),
        pos_w = w() - Fl::box_dw(box()) - spacing(),
        pos_h = h() - Fl::box_dh(box()) - spacing();
    int re_n = 0;
    
    for( int i = 0; i < n; ++i )
    {
      Fl_Widget *o = child( i );
      if( o == re )
      {
        re_n = i;
        break;
      }
      
      if( horizontal() )
      {
        o->position( pos_x, o->y() );
        pos_x += o->w() + spacing();
      } else {
        o->position( o->x(), pos_y );
        pos_y += o->h() + spacing();
      }
    }
    
    for( int i = n - 1; i > re_n; --i )
    {
      Fl_Widget *o = child( i );
      //int X = o->x(), Y = o->y(), W = o->w(), H = o ->h();
      if( horizontal() )
      {
        o->position( pos_w - o->w(), o->y() );
        pos_w -= o->w() + spacing();
      } else {
        o->position( o->x(), pos_h - o->h());
        pos_h -= o->h() + spacing();
      }
    }
    
    if(horizontal())
      re->resize( pos_x, re->y(), pos_w-pos_x, re->h() );
    else
      re->resize( re->x(), pos_y, re->w(), pos_h-pos_y );
  }


  Fl_Pack::draw();} {}
  }
} 

class BoxChoiceCombo {: {public Fl_Pack}
} {
  decl {Fl_Box   *box;} {public
  }
  decl {Fl_Choice*choice;} {public
  }
  Function {BoxChoiceCombo( int x, int y, int w, int h ) : Fl_Pack(x, y, w, h)} {open
  } {}
} 

class Option {: {public OyFlPack} private
} {
  decl {Fl_Box   *box;
  Fl_Choice*choice;

  oyOPTION type;
  int       i;} {public
  }
  Function {Option( int x, int y, int w, int h, const char *name,
  oyOPTION option,
  int choices_n,
  const char **choices,
  const char *tooltip) : OyFlPack(x, y, w, h)} {open
  } {
    code {Fl_Pack::type( FL_HORIZONTAL );
  Fl_Pack::spacing(H_SPACING);
  type = option;


  // == Profiles ==
  if( oyOPTION_DEFAULT_PROFILE_START < option && option < oyOPTION_DEFAULT_PROFILE_END )
  {
    int weigth = BOX_WIDTH + SELECT_WIDTH + 4 * H_SPACING + BUTTON_HEIGHT;
    if(w < weigth)
      Fl_Pack::size( weigth, Fl_Pack::h() );

    w = Fl_Pack::w();

    char *title_text = (char*) new char [256];
    sprintf(title_text, _("%s Profile"), name );

    // Profile name box
    box = new Fl_Box( x, y,
                      w - SELECT_WIDTH - BUTTON_HEIGHT - 4*H_SPACING, BUTTON_HEIGHT,
                      name );
    box->tooltip( tooltip );
    box->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);

    if(type == oyOPTION_ASSUMED_WEB) {
      char* default_p = oyGetDefaultProfileName( (oyDEFAULT_PROFILE)type, myAllocFunc);
      if(default_p) {
        box = new Fl_Box( w - BOX_WIDTH - SELECT_WIDTH - BUTTON_HEIGHT - 3*H_SPACING, y,
                          190, BUTTON_HEIGHT, default_p );
        box->align( FL_ALIGN_LEFT | FL_ALIGN_INSIDE );
        Fl_Group::end();
        Fl_Group::resizable( box );
        return;
      }
    }

    // Choice
    choice = new Fl_Choice( w - SELECT_WIDTH - BUTTON_HEIGHT - 2*H_SPACING, y,
                            SELECT_WIDTH, h );
    choice->callback( selectDefaultProfile_callback );
    choice->tooltip( tooltip );
    DBG_PROG_V((choice->size()))
    choice->add( _("[none]") );
    DBG_PROG_V((choice->size()))

    // Profile viewer
    Fl_Button *button = new Fl_Button( w - BUTTON_HEIGHT - H_SPACING, y,
                                       BUTTON_HEIGHT, BUTTON_HEIGHT, "@-3DnArrow" );
    button->callback( showDefaultProfile_callback );
    button->tooltip(_("Show in external Viewer"));

    // Set choice
    char* default_p = oyGetDefaultProfileName( (oyDEFAULT_PROFILE)type, myAllocFunc );
    if(default_p) {
      DBG_PROG_S( (default_p) )
    } else
      default_p = "";
    int val = 0, occurence = 0;
    for (i = 0; i < choices_n; ++i)
    {
      choice->add( choices[i] );
      if(strstr( choices[i], default_p) && 
         strlen( choices[i] ) == strlen(default_p))
      {
        if(val) {
          ++occurence;
        } else {
          val = i+1;
          ++occurence;
        }
      }
    }
    if(occurence > 1)
      WARN_S(("multiple occurencies of default %s profile: %d times",
               name, occurence))

    DBG_PROG_V((choice->size()))
\#   if ( FL_MAJOR_VERSION >= 1 && FL_MINOR_VERSION >= 1 && FL_PATCH_VERSION >= 6 )
    const Fl_Menu_Item* new_val = choice->find_item(default_p);
    int erfolg = choice->value( new_val );
\#   else
    int size = choice->size(),
        erfolg = 0;
    char menupath[1024] = ""; // File/Export

    char * name = default_p;
    const Fl_Menu_Item *m = 0;
    for ( int t=0; t < choice->size(); t++ ) {
      m = choice->menu() + t;

      if (m->submenu()) {
        // IT'S A SUBMENU
        if (menupath[0]) strncat(menupath, "/", sizeof(menupath));
        strncat(menupath, m->label(), sizeof(menupath));
        if (!strcmp(menupath, name)) break;
      } else {
        if (!m->label()) {
      // END OF SUBMENU? Pop back one level.
      char *ss = strrchr(menupath, '/');
      if ( ss ) *ss = 0;
      else menupath[0] = '\\0';
      continue;
        }

        // IT'S A MENU ITEM
        char itempath[1024];  // eg. Edit/Copy
        strcpy(itempath, menupath);
        if (itempath[0]) strncat(itempath, "/", sizeof(itempath));
        strncat(itempath, m->label(), sizeof(itempath));
        if (!strcmp(itempath, name)) break;
      }
    }

    DBG_PROG_V((size))
    erfolg = choice->Fl_Menu_::value((const Fl_Menu_Item*)m);
\#   endif

    DBG_PROG_V((erfolg))
    DBG_PROG_V((val))

  }


  // == Behaviour ==
  if( oyOPTION_BEHAVIOUR_START < option && option < oyOPTION_BEHAVIOUR_END )
  {
    int weigth = BOX_WIDTH + SELECT_WIDTH + 4 * H_SPACING + BUTTON_HEIGHT;
    if(w < weigth)
      Fl_Pack::size( weigth, Fl_Pack::h() );

    w = Fl_Pack::w();

    char *title_text = (char*) new char [256];
    sprintf(title_text, _("%s Profile"), name );

    // Profile name box
    box = new Fl_Box( x, y,
                      w - SELECT_WIDTH - BUTTON_HEIGHT - 4*H_SPACING, BUTTON_HEIGHT,
                      name );
    box->tooltip( tooltip );
    box->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);

    // Choice
    choice = new Fl_Choice( w - SELECT_WIDTH - H_SPACING, y,
                            SELECT_WIDTH + BUTTON_HEIGHT + H_SPACING, h );
    choice->callback( selectBehaviourCallback );
    choice->tooltip( tooltip );

    // Set choice
    int pos = oyGetBehaviour( (oyBEHAVIOUR)option );

    for (i = 0; i < choices_n; ++i)
    {
      choice->add( choices[i] );
    }
    choice->value( pos );

  }

  
  end();
  resizable( box );} {}
  }
} 

class ProfilePath {: {public Fl_Pack} private
} {
  decl {Fl_Box   *box;
  int       n;
  Fl_Button*button_add, *button_remove;} {public
  }
  Function {ProfilePath( int x, int y, int w, int h, int num )
    : Fl_Pack(x, y, w, h)} {open
  } {
    code {Fl_Pack::type( FL_HORIZONTAL );
    Fl_Pack::spacing(H_SPACING);
    Fl_Group::resizable(0);

    n = num;
    char *name = oyPathName(n, myAllocFunc) ;
    std::cout << name << std::endl;
    //new Fl_Box( 0, 0, 10, 20 );
    box = new Fl_Box( 0, 0, 10, BUTTON_HEIGHT, name );
    box->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);

    if( strcmp( "/usr/share/color/icc", name ) != 0 &&
        strcmp( "~/.color/icc", name ) != 0 )
    {
      button_remove = new Fl_Button( 0, 0, BUTTON_HEIGHT, BUTTON_HEIGHT, "@-31+" );
      button_remove->callback( rmPathCallback );
      button_remove->tooltip(_("Exclude this path"));
      new Fl_Box( 0, 0, H_SPACING, 20 );
    }

    int width=0, height=0;
    int scroll_w = 50; //default_profiles_pack->w() - 3*H_SPACING - BUTTON_HEIGHT;

    box->measure_label(width, height);
    int b_w = scroll_w;
    if(width > scroll_w)
      b_w = width;

    box->size( b_w, 20 );
    Fl_Pack::size( b_w + 2*H_SPACING + BUTTON_HEIGHT, Fl_Pack::h() );} {}
  }
} 

Function {refreshPathLeaves()} {private
} {
  code {paths_scroll->clear();

  int count = oyPathsCount();
  if(count < 2)
    count = oyPathsCount();

  paths_scroll->begin();
  
  Fl_Pack *paths_pack = new Fl_Pack( paths_scroll->x(),paths_scroll->y(),10,10 );
  //paths_pack->box( FL_PLASTIC_UP_FRAME );
  
  ProfilePath *pp = 0;
  int width = 0;
  new Fl_Box(0,0,10, H_SPACING);

  for (int i = 0 ; i < count ; ++i) {
    pp = new ProfilePath( paths_scroll->x(), paths_scroll->y(),
                          50, BUTTON_HEIGHT, i );
    if( width < pp->w() )
      width = pp->w();
    pp->end();
  }

  Fl_Pack *pack = new Fl_Pack(0,0,
                              width, BUTTON_HEIGHT);
    pack->type( FL_HORIZONTAL );
    pack->spacing( H_SPACING );
    Fl_Button *nbutton = new Fl_Button(0,0, width-BUTTON_HEIGHT-2*H_SPACING, BUTTON_HEIGHT, _("@-3+"));
    nbutton->callback( addPathCallback );
    nbutton->tooltip(_("Add Path containing ICC profiles"));
    pack->resizable( nbutton );
    new Fl_Box( 0, 0, 1, 20 );
  pack->end();
  
  new Fl_Box(0,0,10, H_SPACING);

  paths_pack->spacing( V_SPACING );
  paths_pack->size( width + 10, paths_pack->h() );
  paths_pack->end();
  paths_scroll->end();
  paths_scroll->redraw();
  std::cout << nbutton->x() << ","<< nbutton->w() <<std::endl;} {}
} 

Function {addTab( Fl_Tabs* tabs, const oyGROUP *groups )} {open private return_type {Fl_Group*}
} {
  code {Fl_Group *parent = /*dynamic_cast <Fl_Group>*/ tabs; // parent tab
  Fl_Group *tab = NULL; // actual tab

  if( !parent )
    WARN_S( ("wrong widget") );

  for( int k = 1; k <= groups[0]; ++k )
  {
    int i = 0;
    int wcount = parent->children();
    tab = NULL;

    for( i = 0; i < wcount; ++i )
    {
      const char *g_name = oyGetGroupUITitle( groups[k], NULL );
      const char *c_name = parent->child( i )->label(); // current name
      if( c_name && g_name )
      if( strcmp( c_name, g_name ) == 0 )
      {
        // a widget with the searched label was found => tab exists allready
        tab = (Fl_Tabs*) parent->child( i );
        tab->box( FL_THIN_UP_BOX );
        break;
      }
    }

    if( !tab )
    {
      const char *tooltip = NULL;
      const char *title = oyGetGroupUITitle( groups[k], &tooltip );

      parent->begin();
        Fl_Widget *wid = (Fl_Widget*)parent->user_data();
        if( !wid ) wid = parent;

        int x = parent->x() + Fl::box_dx( wid->box() ) + V_SPACING,
            y = parent->y() + Fl::box_dy( wid->box() ) + BUTTON_HEIGHT,// + V_SPACING,
            w = parent->w() - Fl::box_dw( wid->box() ) - 2*V_SPACING,
            h = parent->h() - Fl::box_dh( wid->box() ) - BUTTON_HEIGHT - 2*V_SPACING;
        if( k < groups[0] )
        {
          tab = new Fl_Tabs(   x,y,w,h, title);
          tab->tooltip( tooltip );
          tab->user_data( tab );
          tab->box( FL_THIN_UP_BOX );
          tab->end();
        } else {
          tab = new Fl_Scroll( x,y,w,h, title );
          tab->tooltip( tooltip );
          tab->box( FL_NO_BOX ); //FL_THIN_UP_BOX );
          { OyFlPack* o = new OyFlPack( tab->x() + Fl::box_dx( tab->box() ) + V_SPACING,
                                        tab->y() + Fl::box_dy( tab->box() ) + V_SPACING,// + BUTTON_HEIGHT,
                                        150,
                                        parent->h() - Fl::box_dh( parent->box() ) - BUTTON_HEIGHT );
            o->box( FL_NO_BOX );
            o->spacing( V_SPACING );
            o->end();
            tab->user_data( o );
            tab->resizable( o );
          }
          tab->end();
        }
      parent->end();
      parent->resizable( tab );
    }
    parent = const_cast <Fl_Group*> (dynamic_cast<Fl_Group*>(tab));
  }

  if( tab )
    return (Fl_Group*)tab->user_data();
  else
    return NULL;} {selected
  }
} 

Function {getTab( Fl_Tabs* tabs, oyGROUP group, Fl_Group **container )} {private return_type {Fl_Group*}
} {
  code {Fl_Group *parent = /*dynamic_cast <Fl_Group>*/ tabs; // parent tab
  Fl_Group *tab = NULL; // actual tab

  if( container )
    *container = NULL;

  if( !parent )
    WARN_S( ("wrong widget") );

    int wcount = parent->children();
    tab = NULL;

    for( int i = 0; i < wcount; ++i )
    {
      const char *g_name = oyGetGroupUITitle( group, NULL );
      const char *c_name = parent->child( i )->label(); // current name
      if( c_name && g_name )
      if( strcmp( c_name, g_name ) == 0 )
      {
        tab = (Fl_Tabs*) parent->child( i );
        wcount = tab->children();
        for( i = 0; i < wcount; ++i )
          if( dynamic_cast <Fl_Pack*>( tab->child( i ) ) )
          {
            Fl_Pack *p = dynamic_cast <Fl_Pack*>( tab->child( i ) );
            if( p && p == tab->user_data() )
              *container = p;
            return tab;
          }
        return tab;
      }
    }

  return tab;} {}
} 

Function {refreshOptions()} {private
} {
  code {// remove tabs
  //const char *t = oyGetGroupUITitle( oyGROUP_BEHAVIOUR, NULL );
  Fl_Group   *sg; // sub group
  
  Fl_Group *s = getTab( top_tabs, oyGROUP_BEHAVIOUR, &sg );
  if( s )
  {
    top_tabs->remove( s );
    delete s;
  }
  
  s = getTab( top_tabs, oyGROUP_DEFAULT_PROFILES, &sg );
  if( s )
  {
    top_tabs->remove( s );
    delete s;
  }

  const oyGROUP *groups;
  oyGetOptionUITitle( oyOPTION_EDITING_RGB,
                      &groups, NULL, NULL, NULL );
  addTab( top_tabs, groups );
  oyGetOptionUITitle( oyOPTION_RENDERING_INTENT,
                      &groups, NULL, NULL, NULL );
  addTab( top_tabs, groups );
  oyGetOptionUITitle( oyOPTION_RENDERING_INTENT_PROOF,
                      &groups, NULL, NULL, NULL );
  addTab( top_tabs, groups );
  oyGetOptionUITitle( oyOPTION_ACTION_UNTAGGED_ASSIGN,
                      &groups, NULL, NULL, NULL );
  addTab( top_tabs, groups );


  top_tabs->damage( FL_DAMAGE_ALL );
  top_tabs->redraw();


  int count = 0;

  // pick up all profiles
  char** names = oyProfileList ( 0, &count );

  Option *op = 0;

  // fill in all the standard profiles
  for (oyDEFAULT_PROFILE i = (oyDEFAULT_PROFILE)(oyDEFAULT_PROFILE_START + 1) ;
         i < oyDEFAULT_PROFILE_END ;
            i = (oyDEFAULT_PROFILE)((int)i+1))
      {
        const oyGROUP *groups;
        const char *tooltip;
        const char *name = oyGetOptionUITitle( (oyOPTION)i,
                           &groups, NULL, NULL, &tooltip );
        Fl_Group *w = addTab( top_tabs, groups );
        if(w) w->begin();
          op = new Option( w->x(), w->y(), w->w(), BUTTON_HEIGHT, name,
               (oyOPTION)i, count, const_cast<const char**>(names), tooltip );
        if(w) w->end();
      }

  // resize the top group
  if( op )
  {
    int tw = top_group->w(),
        ow = op->w();
    if( tw < ow )
      top_group->size( ow, top_group->h() );
  }

    //oyProfileListFree( names, count );


  // fill in all the options
  for( oyBEHAVIOUR i = (oyBEHAVIOUR)(oyBEHAVIOUR_START + 1) ;
             i < oyBEHAVIOUR_END ;
                i = (oyBEHAVIOUR)((int)i+1))
      {
        const oyGROUP *groups;
        int            choices = 0;
        const char    *tooltip = NULL;
        const char   **choices_list = NULL;
        const char    *name = oyGetOptionUITitle( (oyOPTION)i,
                              &groups, &choices, &choices_list, &tooltip );
        Fl_Group *w = addTab( top_tabs, groups );
        if(w) w->begin();
          op = new Option( w->x(), w->y(), Fl_Group::current()->w(), BUTTON_HEIGHT, name,
               (oyOPTION)i, choices, /*const_cast<const char**>(*/choices_list, tooltip );
        if(w) w->end();
      }} {}
} 

Function {createUI()} {open
} {
  code {oyPathsCount();
  int count;
  const char **policies_list = getPolicies( &count );

  menu_policy_choice[0].label (policies_list[2*0+0]);
  menu_policy_choice[1].label (policies_list[2*1+0]);
  menu_policy_choice[2].label (policies_list[2*2+0]);
  menu_policy_choice[3].label (policies_list[2*3+0]);

  top_tabs->clear();
  
  top_tabs->begin();

  // Create first tab for policies
  const char *actual_policy = getPolicyName();
  Fl_Group *g = NULL;
      { const char *tooltip = 0;
        const char *label = oyGetGroupUITitle( oyGROUP_POLICY,
                                               &tooltip );
        Fl_Group* o = g = new Fl_Group(10, 101, 485, 260, label);
        o->tooltip( tooltip );
        { Fl_Pack* o = new Fl_Pack(10, 101, 485, 256);
          { Fl_Box* o = new Fl_Box(25, 150, 25, 25);
          }
          { Fl_Choice* o = policy_choice = new Fl_Choice(14, 115, 196, 25);
            o->box(FL_NO_BOX);
            o->down_box(FL_BORDER_BOX);
            o->menu(menu_policy_choice);
          }
          { Fl_Box* o = new Fl_Box(25, 150, 25, 25);
            Fl_Group::current()->resizable(o);
          }
          o->box( FL_NO_BOX );
          o->end();
        }
        o->box( FL_FLAT_BOX );
        o->end();
        Fl_Group::current()->resizable(o);
      }
      { const char *tooltip = 0;
        const char *label = oyGetGroupUITitle( oyGROUP_PATHS,
                                               &tooltip );
        Fl_Group* o = g = new Fl_Group(10, 95, 485, 266, label);
        o->tooltip( tooltip );
        o->box( FL_NO_BOX );
        o->hide();
        { Fl_Scroll* o = paths_scroll = new Fl_Scroll(10, 100, 490, 261);
          o->box( FL_NO_BOX );
          o->end();
        }
        o->end();
      }

  top_tabs->end();


  for( int i = 0; i < count; ++i )
  {
    if( strstr( policies_list[2*i+0], actual_policy ) )
      policy_choice->value( i );
      policy_box->label( actual_policy );
  }

  refreshOptions();
  //listWindow(top_tabs);
  refreshPathLeaves();
  //listWindow(top_tabs);} {}
} 

Function {updateUI()} {} {
  code {refreshOptions();
  refreshPathLeaves();

  policy_box->label( getPolicyName() );} {}
} 

Function {} {open private
} {
  code {Fl::scheme("plastic");} {}
  Fl_Window top_group {
    label {Oyranos Configuration} open
    xywh {725 297 505 410} type Double resizable size_range {305 255 0 0} visible
  } {
    Fl_Pack {} {open
      xywh {0 0 480 70} type HORIZONTAL
    } {
      Fl_Box {} {
        image {oyranos_logo.png} xywh {0 0 85 70} align 16
      }
      Fl_Box {} {
        label {Oyranos Configuration }
        xywh {95 0 385 70} labeltype ENGRAVED_LABEL labelsize 18 align 24 resizable
        code0 {o->redraw();}
      }
    }
    Fl_Tabs top_tabs {open
      xywh {0 70 505 301} resizable
    } {
      Fl_Group {} {
        label Policy open
        tooltip {Reset to a standard Policy for Oyranos.} xywh {10 95 485 266} resizable
      } {
        Fl_Pack {} {open
          xywh {10 105 485 256}
        } {
          Fl_Box {} {
            xywh {30 180 25 25}
          }
          Fl_Choice policy_choice {open
            xywh {30 155 196 25} box NO_BOX down_box BORDER_BOX
          } {
            MenuItem {} {
              label {Office + Home}
              callback {setPolicy( 0 );}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label {Graphic Designers}
              callback {setPolicy( 1 );}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label PrePress
              callback {setPolicy( 2 );}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label Photographers
              callback {setPolicy( 3 );}
              xywh {15 15 100 20}
            }
          }
          Fl_Box {} {
            xywh {40 190 25 25} resizable
          }
        }
      }
      Fl_Group {} {
        label Paths open
        tooltip {Configure Paths} xywh {10 95 485 266} hide
      } {
        Fl_Scroll paths_scroll {open
          xywh {10 100 485 261}
        } {}
      }
    }
    Fl_Button {} {
      label {@-3reload}
      callback {//Fl::pushed(&bPL);
  updateUI();}
      tooltip Refresh xywh {10 375 50 25} when 6
    }
    Fl_Pack {} {open
      xywh {160 371 255 35} type HORIZONTAL
    } {
      Fl_Box {} {
        label {Active Policy:}
        xywh {160 371 120 35} align 20
      }
      Fl_Box policy_box {
        label {----}
        xywh {280 371 135 35} align 20
      }
    }
  }
  code {createUI();
  //oy_debug=1;} {}
} 

Function {listWindow( Fl_Widget *w )} {} {
  code {Fl_Group *g = dynamic_cast <Fl_Group*> (w);

  static int level = 0;


  if( g )
  {
    int n = g->children();

    std::cout << std::endl;
    for(int i = 0; i < level; ++i) std::cout << " ";

    std::cout << "Group t" << (int)w->type() << " " << w->parent()<<"|"<< w << " " << w->x()<<"+"<<w->y()<<"+"<<w->w()<<"x"<<w->h() <<
                 " \\"" << (w->label()?w->label():"") << "\\":";

    ++level;
    for( int i = 0; i < n; ++i )
    {
      listWindow( g->child(i) );
    }
    --level;
    std::cout << std::endl;
  } else
  {
    std::cout << " t" << (int)w->type() << " " << w->parent()<<"|"<< w << " " << w->x()<<"+"<<w->y()<<"+"<<w->w()<<"x"<<w->h() <<
                 " " << (w->label()?w->label():"- ");
  }} {}
} 
